#!/usr/bin/env bats
# tests/test_aws/test_scripts/test_s3_utils.bats
#
# NOTE: This test suite was generated by GPT-5 and reviewed/checked by Dor Fuchs.
#
# Unit tests for s3_utils.sh (no real AWS calls).
# - Stubs the `aws` CLI via a shim placed at the front of PATH.
# - Verifies exit codes, messages (stdout/stderr), and call args.
#
# Requires: bats-core, bats-support, bats-assert (Homebrew installs)
# Optional: bats-file
bats_require_minimum_version 1.5.0

# ----- Load libraries (works on macOS/Homebrew and CI) -----
BATS_PREFIX="${BATS_PREFIX:-$(command -v brew >/dev/null 2>&1 && brew --prefix || echo /usr/local)}"
if [[ -f "${BATS_PREFIX}/lib/bats-support/load.bash" ]]; then
  load "${BATS_PREFIX}/lib/bats-support/load.bash"
  load "${BATS_PREFIX}/lib/bats-assert/load.bash"
  load "${BATS_PREFIX}/lib/bats-file/load.bash"
else
  load 'bats-support/load.bash'
  load 'bats-assert/load.bash'
  load 'bats-file/load.bash'
fi
# -----------------------------------------------------------

setup_file() {
  local default_src="aws/scripts/s3_utils.sh"
  S3_UTILS_SRC="${S3_UTILS_SRC:-$default_src}"

  FIXDIR="${BATS_FILE_TMPDIR}/s3_utils_fixture"
  mkdir -p "$FIXDIR"

  if [[ ! -f "$S3_UTILS_SRC" ]]; then
    echo "s3_utils.sh not found at: $S3_UTILS_SRC" >&2
    echo "Set S3_UTILS_SRC to your file path before running." >&2
    S3_UTILS_MISSING=1
    export S3_UTILS_MISSING
    return 0
  fi

  cp "$S3_UTILS_SRC" "$FIXDIR/s3_utils.sh"

  # Shim `aws` in a bin dir we prepend to PATH
  BIN="$FIXDIR/bin"
  mkdir -p "$BIN"

  # Call log for inspecting which aws subcommands were executed
  CALL_LOG="$FIXDIR/calls.log"
  : >"$CALL_LOG"

  # Create an `aws` shim that:
  # - logs subcommand and relevant flags to CALL_LOG
  # - exits with codes controlled by env vars:
  #     AWS_HEAD_OBJECT_RC, AWS_HEAD_BUCKET_RC, AWS_PUT_OBJECT_RC
  cat >"$BIN/aws" <<'AWSSTUB'
#!/usr/bin/env bash
# Log full invocation (space-joined) for debugging
echo "aws $*" >>"$CALL_LOG"

# Very light routing on "s3api <verb>"
if [[ "$1" == "s3api" && "$2" == "head-object" ]]; then
  exit "${AWS_HEAD_OBJECT_RC:-0}"
elif [[ "$1" == "s3api" && "$2" == "head-bucket" ]]; then
  exit "${AWS_HEAD_BUCKET_RC:-0}"
elif [[ "$1" == "s3api" && "$2" == "put-object" ]]; then
  exit "${AWS_PUT_OBJECT_RC:-0}"
else
  # Unknown call: be loud to the log, non-zero to catch mistakes
  echo "UNEXPECTED aws call: $*" >>"$CALL_LOG"
  exit 2
fi
AWSSTUB
  chmod +x "$BIN/aws"

  export FIXDIR BIN CALL_LOG
}

setup() {
  [[ "${S3_UTILS_MISSING:-0}" == 1 ]] && skip "s3_utils.sh missing; set S3_UTILS_SRC and rerun"

  # Per-test clean log and a fresh PATH that points to our shim
  : >"$CALL_LOG"
  export PATH="$BIN:$PATH"

  # Where we source the file from (and where s3_utils will expect ./ relative includes)
  export S3_UTILS_PATH="$FIXDIR/s3_utils.sh"
}

# Helper: run a function from s3_utils with strict mode, capturing stderr separately.
# Also provide a minimal `die` so parse_s3_uri can error coherently on empty input.
_run_utils() {
  cd "$FIXDIR" || exit
  run --separate-stderr bash -c '
    set -euo pipefail
    die(){ echo "$1" >&2; exit 1; }
    source "$S3_UTILS_PATH"
    '"$*"'
  '
}

# ---------------- parse_s3_uri ----------------

@test "parse_s3_uri happy path sets PARSED_BUCKET and PARSED_KEY" {
  _run_utils 'parse_s3_uri "s3://my-bucket/a/b/c/"; echo "B=$PARSED_BUCKET K=$PARSED_KEY"'
  assert_success
  assert_equal "$output" "B=my-bucket K=a/b/c/"
  assert_equal "$stderr" ""
}

@test "parse_s3_uri rejects invalid scheme and returns 1 with message on stdout" {
  _run_utils 'parse_s3_uri "http://x/y"'
  assert_failure
  assert_equal "$output" "invalid S3 URI (expected s3://bucket/key): http://x/y"
  assert_equal "$stderr" ""
}

@test "parse_s3_uri empty string dies with curated message (stderr)" {
  _run_utils 'parse_s3_uri ""'
  assert_failure
  assert_equal "$output" ""
  assert_equal "$stderr" "empty S3 URI"
}

# ---------------- check_object_access ----------------

@test "check_object_access returns 0 when head-object succeeds" {
  export AWS_HEAD_OBJECT_RC=0
  _run_utils 'check_object_access "bkt" "path/to.obj"'
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
  # confirm we actually called head-object
  run grep -n "s3api head-object" "$CALL_LOG"
  assert_success
}

@test "check_object_access returns 1 and prints message when head-object fails" {
  export AWS_HEAD_OBJECT_RC=1
  _run_utils 'check_object_access "bkt" "path/to.obj"'
  assert_failure
  assert_equal "$output" "Output file path/to.obj does not exist or is not accessible."
  assert_equal "$stderr" ""
  run grep -n "s3api head-object" "$CALL_LOG"
  assert_success
}

# ---------------- check_bucket_access ----------------

@test "check_bucket_access returns 0 when head-bucket succeeds" {
  export AWS_HEAD_BUCKET_RC=0
  _run_utils 'check_bucket_access "bkt"'
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
  run grep -n "s3api head-bucket" "$CALL_LOG"
  assert_success
}

@test "check_bucket_access returns 1 and prints message when head-bucket fails" {
  export AWS_HEAD_BUCKET_RC=1
  _run_utils 'check_bucket_access "bkt"'
  assert_failure
  assert_equal "$output" "Bucket bkt does not exist or is not accessible."
  assert_equal "$stderr" ""
  run grep -n "s3api head-bucket" "$CALL_LOG"
  assert_success
}

# ---------------- check_can_write_prefix ----------------

@test "check_can_write_prefix returns 0, prints NOTE to stderr, and calls put-object" {
  export AWS_PUT_OBJECT_RC=0
  _run_utils 'check_can_write_prefix "bucket" "out/prefix/"'
  assert_success
  # stderr contains dynamic canary; check key parts only
  [[ "$stderr" == Note:* ]] || { echo "stderr missing leading Note:"; false; }
  [[ "$stderr" == *"s3://bucket/out/prefix/"* ]] || { echo "stderr missing bucket/prefix"; false; }
  [[ "$stderr" == *"__canary__."* ]] || { echo "stderr missing __canary__ marker"; false; }
  run grep -n "s3api put-object" "$CALL_LOG"
  assert_success
}

@test "check_can_write_prefix returns 1 and prints curated message when PutObject denied" {
  export AWS_PUT_OBJECT_RC=1
  _run_utils 'check_can_write_prefix "bucket" "out/prefix/"'
  assert_failure
  assert_equal "$output" "no PutObject permission at s3://bucket/out/prefix/"
  assert_equal "$stderr" ""
  run grep -n "s3api put-object" "$CALL_LOG"
  assert_success
}
