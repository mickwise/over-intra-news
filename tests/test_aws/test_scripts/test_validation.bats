#!/usr/bin/env bats
# tests/test_aws/test_scripts/test_validation.bats
#
# NOTE: This test suite was generated by GPT 5 and reviewed/checked by Dor Fuchs.
#
# Unit tests for validation.sh (pure validation behaviors, no AWS/network).
# - Stubs only the s3_utils.sh functions that validation.sh calls.
# - Asserts exact exit codes, stderr messages, and call ordering.
#
# Requires: bats-core, bats-support, bats-assert (installed locally via Homebrew)
# Optional: bats-file (for simple fs assertions)
bats_require_minimum_version 1.5.0

# -------- Library loading that works on macOS (Homebrew) and CI -------------
# Try a Homebrew absolute path first, then fall back to BATS_LIB_PATH search.
BATS_PREFIX="${BATS_PREFIX:-$(command -v brew >/dev/null 2>&1 && brew --prefix || echo /usr/local)}"
if [[ -f "${BATS_PREFIX}/lib/bats-support/load.bash" ]]; then
  load "${BATS_PREFIX}/lib/bats-support/load.bash"
  load "${BATS_PREFIX}/lib/bats-assert/load.bash"
  load "${BATS_PREFIX}/lib/bats-file/load.bash"
else
  # CI path: relies on BATS_LIB_PATH (set by bats-action) to resolve these
  load 'bats-support/load.bash'
  load 'bats-assert/load.bash'
  load 'bats-file/load.bash'
fi
# ---------------------------------------------------------------------------

setup_file() {
  local default_src="aws/scripts/validation.sh"
  VALIDATION_SRC="${VALIDATION_SRC:-$default_src}"
  VALIDATION_MISSING=0

  FIXDIR="${BATS_FILE_TMPDIR}/validation_fixture"
  mkdir -p "$FIXDIR"

  if [[ ! -f "$VALIDATION_SRC" ]]; then
    echo "validation.sh not found at: $VALIDATION_SRC" >&2
    echo "Set VALIDATION_SRC to your file path before running." >&2
    VALIDATION_MISSING=1
    return 0
  fi

  cp "$VALIDATION_SRC" "$FIXDIR/validation.sh"

  CALL_LOG="$FIXDIR/calls.log"
  : >"$CALL_LOG"

  export FIXDIR CALL_LOG VALIDATION_MISSING

  # Minimal stub s3_utils.sh:
  #  - logs function invocations for order assertions
  #  - simulates success/failure via env flags (BUCKET_OK, WRITE_OK)
  #  - mirrors your real error messages
  cat >"$FIXDIR/s3_utils.sh" <<'STUB'
# ---- s3_utils.sh (stub for tests) ----
parse_s3_uri() {
  local uri="$1"
  echo "parse_s3_uri ${uri}" >>"$CALL_LOG"
  if [[ "$uri" =~ ^s3://([^/]+)/(.+)$ ]]; then
    PARSED_BUCKET="${BASH_REMATCH[1]}"
    PARSED_KEY="${BASH_REMATCH[2]}"
    return 0
  else
    echo "invalid S3 URI (expected s3://bucket/key): $uri"
    return 1
  fi
}

check_bucket_access() {
  local bucket="$1"
  echo "check_bucket_access ${bucket}" >>"$CALL_LOG"
  if [[ "${BUCKET_OK:-1}" -eq 1 ]]; then
    return 0
  else
    echo "Bucket ${bucket} does not exist or is not accessible."
    return 1
  fi
}

check_can_write_prefix() {
  local bucket="$1" prefix="$2"
  echo "check_can_write_prefix ${bucket} ${prefix}" >>"$CALL_LOG"
  if [[ "${WRITE_OK:-1}" -eq 1 ]]; then
    # mimic note to stderr for success; tests don't assert on this
    echo "Note: wrote canary at s3://${bucket}/${prefix}.__canary__.$(date +%s).$$" 1>&2
    return 0
  else
    echo "no PutObject permission at s3://${bucket}/${prefix}"
    return 1
  fi
}
STUB
}

setup() {
  local default_src="aws/scripts/validation.sh"
  VALIDATION_SRC="${VALIDATION_SRC:-$default_src}"
  FIXDIR="${BATS_FILE_TMPDIR}/validation_fixture"
  mkdir -p "$FIXDIR"
    CALL_LOG="$FIXDIR/calls.log"
  : >"$CALL_LOG"

  [[ "$VALIDATION_MISSING" == 1 ]] && skip "validation.sh missing; set VALIDATION_SRC and rerun"
  : >"$CALL_LOG"
  unset BUCKET_OK WRITE_OK
  export CALL_LOG BUCKET_OK WRITE_OK
  export VALIDATION_PATH="$FIXDIR/validation.sh"
  export FIXDIR CALL_LOG
}

# helper: run a validator under strict mode; capture stderr separately
_run_with_errexit() {
  cd "$FIXDIR" || exit
  run --separate-stderr bash -c "set -euo pipefail; source \"$VALIDATION_PATH\"; $*"
}

# -------------------- die --------------------
@test "die exits 1 and writes message to stderr" {
  cd "$FIXDIR" || exit
  run --separate-stderr bash -c "source \"$VALIDATION_PATH\"; die 'boom'"
  assert_failure
  assert_equal "$output" ""
  assert_equal "$stderr" "boom"
}

# ---------------- assert_prefix_shape ----------------
@test "assert_prefix_shape accepts valid prefix (trailing slash)" {
  _run_with_errexit "assert_prefix_shape 's3://bucket/path/'"
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
  run cat "$CALL_LOG"
  assert_line --index 0 "parse_s3_uri s3://bucket/path/"
}

@test "assert_prefix_shape rejects object-like URI with curated message" {
  _run_with_errexit "assert_prefix_shape 's3://bucket/a.txt'"
  assert_failure
  assert_equal "$output" ""
  assert_equal "$stderr" "output must be a prefix ending with '/': s3://bucket/a.txt"
  run cat "$CALL_LOG"
  assert_line --index 0 "parse_s3_uri s3://bucket/a.txt"
}

# --------------- validate_s3_output_prefix ---------------
@test "validate_s3_output_prefix happy path: parse -> head-bucket -> put-object (order) and success" {
  export BUCKET_OK=1 WRITE_OK=1
  _run_with_errexit "validate_s3_output_prefix 's3://bucket/out/'"
  assert_success
  run awk '{print NR": "$0}' "$CALL_LOG"
  assert_line --index 0 "1: parse_s3_uri s3://bucket/out/"
  assert_line --index 1 "2: check_bucket_access bucket"
  assert_line --index 2 "3: check_can_write_prefix bucket out/"
}

@test "validate_s3_output_prefix invalid shape fails early; no bucket/write checks" {
  _run_with_errexit "validate_s3_output_prefix 's3://bucket/out'"
  assert_failure
  assert_equal "$stderr" "output must be a prefix ending with '/': s3://bucket/out"
  run cat "$CALL_LOG"
  assert_line --index 0 "parse_s3_uri s3://bucket/out"
  [ "${#lines[@]}" -eq 1 ]
}

@test "validate_s3_output_prefix bucket inaccessible bubbles message and stops" {
  export BUCKET_OK=0
  _run_with_errexit "validate_s3_output_prefix 's3://bucket/out/'"
  assert_failure
  assert_equal "$output" "Bucket bucket does not exist or is not accessible."
  run cat "$CALL_LOG"
  assert_line --index 0 "parse_s3_uri s3://bucket/out/"
  assert_line --index 1 "check_bucket_access bucket"
  [ "${#lines[@]}" -eq 2 ]
}

@test "validate_s3_output_prefix no PutObject permission bubbles message" {
  export BUCKET_OK=1 WRITE_OK=0
  _run_with_errexit "validate_s3_output_prefix 's3://bucket/out/'"
  assert_failure
  assert_equal "$output" "no PutObject permission at s3://bucket/out/"
  run cat "$CALL_LOG"
  assert_line --index 0 "parse_s3_uri s3://bucket/out/"
  assert_line --index 1 "check_bucket_access bucket"
  assert_line --index 2 "check_can_write_prefix bucket out/"
}

# --------------------- validate_arg ---------------------
@test "validate_arg missing value (empty string) triggers error" {
  _run_with_errexit "validate_arg --year ''"
  assert_failure
  assert_equal "$stderr" "Missing value for --year"
}

@test "validate_arg next token is another flag triggers error" {
  _run_with_errexit "validate_arg --year -x"
  assert_failure
  assert_equal "$stderr" "Missing value for --year"
}

@test "validate_arg normal value passes" {
  _run_with_errexit "validate_arg --cap 10"
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
}

# --------------------- validate_year ---------------------
@test "validate_year empty" {
  _run_with_errexit "validate_year ''"
  assert_failure
  assert_equal "$stderr" "Year is required."
}

@test "validate_year non-4-digit fails" {
  _run_with_errexit "validate_year '201'"
  assert_failure
  assert_equal "$stderr" "Year must be a four-digit number."
  _run_with_errexit "validate_year '2019x'"
  assert_failure
  assert_equal "$stderr" "Year must be a four-digit number."
}

@test "validate_year 4-digit passes" {
  _run_with_errexit "validate_year '2019'"
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
}

# --------------- validate_positive_integer ---------------
@test "validate_positive_integer rejects zero, negative, non-numeric" {
  _run_with_errexit "validate_positive_integer '0'"
  assert_failure
  assert_equal "$stderr" "Daily cap must be a positive integer."
  _run_with_errexit "validate_positive_integer '-5'"
  assert_failure
  assert_equal "$stderr" "Daily cap must be a positive integer."
  _run_with_errexit "validate_positive_integer 'abc'"
  assert_failure
  assert_equal "$stderr" "Daily cap must be a positive integer."
}

@test "validate_positive_integer accepts positive integers" {
  _run_with_errexit "validate_positive_integer '1'"
  assert_success
  assert_equal "$output" ""
  assert_equal "$stderr" ""
}
